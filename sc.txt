// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract HealthManagement {

    struct Record{

        string docname;
        string fileHashes;
        string presciptions;
        address payable doctor_;
        uint256 timeStamp;
        uint256 amount;
        string patientName;
        address payable patientaddr;
  
    }


    struct Patient{
        string name;
        string email;
        address payable address_;
        uint256 phone;
        uint256 age;
        Record [] records_;
        string bloodgroup;
        uint256 dob;
        Appointment [] myAppointments;
    }

    struct Doctor{
        string name;
        address payable address_;
        // address [] doctorToPatient;
        uint256 basefee;
        uint256 starCount;
        uint256 totalPatients;
        Appointment []  appointments_;
        Record [] records_;
        // mapping( address => uint) myPatients;
    }
    // APPOINTMENT
    struct Appointment{
        // address doctor_;
        bool status;
        address payable patient_;
        address payable doctor_;
        string patientName;
        string docname;
        uint256 timeslot_;
        uint256 timeStart;
        uint256 timeEnd;
    }


    // all data members 

    address owner_;
    Appointment [] public allAppointments;
    address [] public alldoctors;
    address []public allPatientsList;
    mapping (address=>bool)public isDoctor;
    mapping (address => Doctor)public allDoctors;
    mapping( address => bool)public isPatient;
    // mapping( address => bool)public isDoctor;
    mapping( address => Patient) public allPatients;
    // mapping( address => Record []) public patientRecords;

    uint256 patientCount;
    uint256 doctorCount ;
    uint256 appointmentCount;
    
    constructor(){
        patientCount = 0;
        doctorCount = 0;
        appointmentCount = 0;
        owner_ = msg.sender;
    }
    // all funciton members : 

    function  addPatient(string memory name,uint256 phone,uint256 age,uint256 dob,string memory email) public {
        require(isPatient[msg.sender] == false,"You are already a patient ");
        isPatient[msg.sender] = true;
        allPatients[msg.sender].name= name;
        allPatients[msg.sender].address_= payable((msg.sender));
        allPatients[msg.sender].age= age;
        allPatients[msg.sender].phone= phone;
        allPatients[msg.sender].dob= dob;
        allPatients[msg.sender].email= email;
        allPatientsList.push(msg.sender);
        patientCount+=1;
    } 

    function getPatientDetails(address addr) public view returns(
        string memory name,string memory email,uint256  age, uint256  phone,
        string memory bloodgroup , uint256  dob ) {

        require(isPatient[addr],"You are not a patient");
        Patient memory p = allPatients[addr];
        return (p.name,p.email,p.age,p.phone,p.bloodgroup,p.dob);
    }
    
    function addPatientRecord(
        string memory currentfiles,
        string memory presciptions,
        address payable doctor_,
        string memory docname,
        string memory patientName,
        address payable patientaddr
        ) public payable {

        require(isPatient[patientaddr],"You are not a patient");
        require(isDoctor[msg.sender],"You are not a Doctor");
        // might have to do storage

        allPatients[patientaddr].records_.push(Record(docname,currentfiles,presciptions,doctor_,block.timestamp,msg.value  ,patientName,patientaddr));
        allDoctors[doctor_].records_.push(Record(docname,currentfiles,presciptions,doctor_,block.timestamp,msg.value,patientName,patientaddr));
        
    }
    
    function getPatientRecords(address addr) public view returns( Record[] memory records ) {

        require(isPatient[addr],"You are not a patient");
        Record [] memory r = allPatients[addr].records_;
        return (r);
    }

    function getOneRecord(address addr,uint256 index) public view returns (Record memory rec) {
        Record memory r = allPatients[addr].records_[index];
        return (r);
    }

    function getRecordOfOnePatient(address p) public view returns ( Record[] memory doctorRecord ){
        Patient memory P = allPatients[p];
        uint count = 0;
        uint pos = 0;
        for(uint i=0 ; i < P.records_.length  ;i++)
            if(P.records_[i].doctor_ == msg.sender)count+=1;
        
        Record [] memory temp = new Record[](count) ;

        for(uint i=0 ; i < P.records_.length  ;i++)
            if(P.records_[i].doctor_ == msg.sender){
               temp[pos] = P.records_[i];
               pos++;
            }

        return (temp);
    }

   // register doctor 

   function addDoctor(
        string memory name,
        address payable address_,
        uint256 basefee
        ) public  {

        require(isDoctor[msg.sender] == false,"You are already a doctor ");
        
        alldoctors.push(msg.sender);
        allDoctors[msg.sender].name = name;
        allDoctors[msg.sender].address_ = address_;
        allDoctors[msg.sender].basefee = basefee;
        allDoctors[msg.sender].starCount = 0;
        allDoctors[msg.sender].totalPatients = 0;
        doctorCount += 1;
   }

   function payFees(address to)public payable returns (bool sent) {
       require(msg.value >= allDoctors[to].basefee , " Insufficient funds ");
       (bool sent, bytes memory data) = (address(payable(to))).call{value: msg.value}("");
        return sent;
        // require(sent, "Failed to send Ether");
   }

   function takeAppointment(address payable docAddr,uint256 slot) public {
        bool done =  payFees(docAddr);
        require(done , "Failed to send Ether");
        Appointment memory a = Appointment(false, payable(msg.sender),docAddr,allPatients[msg.sender].name , allDoctors[docAddr].name , slot,0,0);
        allDoctors[docAddr].appointments_.push(a);
        allPatients[msg.sender].myAppointments.push(a);
        // add to patients appointments too 
   }

    function startAppointment(uint256 index,uint256 start) public {
        require(allDoctors[msg.sender].appointments_[index].status == false,"You have completed this appointment");
        allDoctors[msg.sender].appointments_[index].status = true;
        allDoctors[msg.sender].appointments_[index].timeStart = start;
    }

    function endAppointment(uint256 index,uint256 end) public{
       require(allDoctors[msg.sender].appointments_[index].status == true,"You have not completed this appointment");
        allDoctors[msg.sender].appointments_[index].timeEnd = end;
    }
    
    function getAllDoctor() public view returns(Doctor [] memory alldocs ) {
        Doctor [] memory docs = new Doctor[](doctorCount);
        for(uint i = 0; i < doctorCount ; i++)docs[i] = allDoctors[ alldoctors[i] ];
        return docs;
    }

    function getOneDoctor(address addr) public view returns (Doctor memory doc){
        Doctor memory d = allDoctors[addr];
        return d;
    }

}